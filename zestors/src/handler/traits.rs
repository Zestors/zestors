use crate::all::*;
use async_trait::async_trait;

pub type HandlerInbox<H> = <<H as Handler>::State as HandlerState<H>>::InboxType;
pub type HandlerProtocol<H> = <<H as Handler>::State as HandlerState<H>>::Protocol;
pub type HandlerConfig<H> = <HandlerInbox<H> as ActorInbox>::Config;

/// The  [`Handler`] trait is used together with the following three [async traits](async_trait) to
/// define the lifecycle of an actor:
/// - [`HandleMessage<M>`] --> Specifies how a message `M` is handled.
/// - [`HandleExit`] --> Specifies how the actor's exit is handled.
/// - [`HandleInit<I>`] --> Specifies how the actor's initialization with `I` is handled.
///
/// See [`HandlerExt`] for how to interact with the handler.
#[async_trait]
pub trait Handler: Sized + Send + 'static {
    /// The exception that can be returned from any handler function.
    type Exception: Send + 'static;

    /// The state passed along to every handler function. (Usually an inbox)
    type State: HandlerState<Self>;

    /// Handle an event generated by the [`Self::State`].
    async fn handle_event(
        &mut self,
        state: &mut Self::State,
        event: Event,
    ) -> Result<Flow, Self::Exception> {
        match event {
            Event::Halt => {
                state.close();
                Ok(Flow::Continue)
            }
            Event::ClosedAndEmpty => Ok(Flow::Stop),
            Event::Dead => Ok(Flow::Stop),
        }
    }
}

/// Specifies how the [`Handler`] handles a message `M`.
#[async_trait]
pub trait HandleMessage<M: Message>: Handler {
    async fn handle_msg(
        &mut self,
        state: &mut Self::State,
        msg: M::Payload,
    ) -> Result<Flow, Self::Exception>;
}

/// Specifies how the [`Handler`] handles it's exit.
#[async_trait]
pub trait HandleExit: Handler {
    /// The value that the process exits with.
    type Exit: Send + 'static;

    async fn handle_exit(
        self,
        state: &mut Self::State,
        reason: ExitReason<Self::Exception>,
    ) -> ExitFlow<Self>;
}

#[derive(Debug)]
pub enum ExitReason<E> {
    Stop,
    Exception(E),
}

/// Specifies how the [`Handler`] handles it's initialization.
#[async_trait]
pub trait HandleInit<I>: HandleExit {
    /// The returned reference to the actor. (Usually [`Address<HandlerInbox<Self>>`])
    type Ref: Send + 'static;

    /// The error that can occur when starting. (If none, then use [`Infallible`])
    type StartError: Send + 'static;

    /// The initiation-process on the spawning-process.
    async fn init(
        child: Child<Self::Exit, HandlerInbox<Self>>,
        address: Address<HandlerInbox<Self>>,
    ) -> Result<(Child<Self::Exit, HandlerInbox<Self>>, Self::Ref), Self::StartError>;

    /// The initiation-process on the spawned process.
    async fn handle_init(init: I, state: &mut Self::State) -> Result<Self, Self::Exit>;
}

/// Specifies that a [`Protocol`] can be handled by the [`Handler`] `H`.
///
/// Normally this is automatically implemented using the [`protocol`] macro.
#[async_trait]
pub trait HandledBy<H: Handler> {
    async fn handle_with(self, handler: &mut H, state: &mut H::State)
        -> Result<Flow, H::Exception>;
}

/// What the [`Handler::handle_exit`] function can return.
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub enum ExitFlow<H: HandleExit> {
    /// Continue exiting with [`H::Exit`].
    Exit(H::Exit),
    /// Resume execution with `H`.
    Resume(H),
}

/// The `Ok(_)` value of a handler-function.
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub enum Flow {
    /// Continue regular execution of the actor.
    Continue,
    /// Stop execution of the actor.
    /// This calls [`Handler::handle_exit`] with `exception: None`.
    Stop,
}

/// An extension to [`Handler`] with many useful functions.
#[async_trait]
pub trait HandlerExt: Handler {
    async fn handle_protocol(
        &mut self,
        state: &mut Self::State,
        msg: HandlerProtocol<Self>,
    ) -> Result<Flow, Self::Exception> {
        msg.handle_with(self, state).await
    }

    async fn start<I: Send + 'static>(
        init: I,
    ) -> Result<(Child<Self::Exit, HandlerInbox<Self>>, Self::Ref), Self::StartError>
    where
        Self: HandleInit<I>,
        HandlerConfig<Self>: Default,
    {
        Self::start_with(init, Default::default(), Default::default()).await
    }

    async fn start_with<I: Send + 'static>(
        init: I,
        link: Link,
        cfg: HandlerConfig<Self>,
    ) -> Result<(Child<Self::Exit, HandlerInbox<Self>>, Self::Ref), Self::StartError>
    where
        Self: HandleInit<I>,
    {
        let (child, address) = spawn_with(link, cfg, |inbox| async move {
            let mut state = <Self::State as HandlerState<Self>>::from_inbox(inbox);

            match Self::handle_init(init, &mut state).await {
                Ok(handler) => handler.run(&mut state).await,
                Err(exit) => exit,
            }
        });

        Self::init(child, address).await
    }

    fn spawn(
        self,
    ) -> (
        Child<Self::Exit, HandlerInbox<Self>>,
        Address<HandlerInbox<Self>>,
    )
    where
        Self: HandleExit,
        HandlerConfig<Self>: Default,
    {
        self.spawn_with(Default::default(), Default::default())
    }

    fn spawn_with(
        self,
        link: Link,
        cfg: HandlerConfig<Self>,
    ) -> (
        Child<Self::Exit, HandlerInbox<Self>>,
        Address<HandlerInbox<Self>>,
    )
    where
        Self: HandleExit,
    {
        spawn_with(link, cfg, |inbox| async move {
            let mut state = <Self::State as HandlerState<Self>>::from_inbox(inbox);
            self.run(&mut state).await
        })
    }

    async fn run(mut self, state: &mut Self::State) -> Self::Exit
    where
        Self: HandleExit,
    {
        loop {
            let handled_item = state
                .next_handler_item()
                .await
                .handle_with(&mut self, state)
                .await;

            let exit_flow = match handled_item {
                Ok(flow) => match flow {
                    Flow::Continue => ExitFlow::Resume(self),
                    Flow::Stop => self.handle_exit(state, ExitReason::Stop).await,
                },
                Err(exception) => {
                    self.handle_exit(state, ExitReason::Exception(exception))
                        .await
                }
            };

            self = match exit_flow {
                ExitFlow::Exit(exit) => break exit,
                ExitFlow::Resume(handler) => handler,
            }
        }
    }
}
impl<T: Handler> HandlerExt for T {}
