use std::{
    net::SocketAddr,
    ops::{Deref, DerefMut},
};

use futures::{FutureExt, Stream, StreamExt};
use serde::{Deserialize, Serialize};
use sha2::{digest::Digest, Sha256};
use tokio::net::TcpStream;
use tokio_tungstenite::MaybeTlsStream;
use uuid::Uuid;
// use sha2::Digest;
use super::{
    local_node::{self, LocalNode},
    msg::{self, RawMsg},
    server::NodeConnectError,
    ws_stream::{WsRecvError, WsStream},
    NodeId,
};
use crate::into_msg;

//------------------------------------------------------------------------------------------------
//  Challenge structs
//------------------------------------------------------------------------------------------------

/// A challenge, that can be sent to a node to verify that their build_id and
/// token are actually the same. This challenge is just a randomly generated
/// uuid, which must be hashed together with the build_id and token to create
/// a [ChallengeReply].
#[derive(Serialize, Deserialize, PartialEq, Eq, Clone, Copy, Debug, Hash)]
pub struct Challenge(Uuid);

/// A reply to a [Challenge], generated by hashing the [Challenge] together
/// with the build_id and
#[derive(Serialize, Deserialize, PartialEq, Eq, Clone, Debug)]
pub struct ChallengeReply {
    build_hash: Box<[u8]>,
    token_hash: Box<[u8]>,
}

impl ChallengeReply {
    fn new(local_node: &LocalNode, challenge: &Challenge) -> Self {
        let mut build_hash = Sha256::new();
        build_hash.update(challenge.0.as_bytes());
        build_hash.update(local_node.build_id().as_bytes());
        let build_hash: Box<[u8]> = build_hash.finalize().as_slice().into();

        let mut token_hash = Sha256::new();
        token_hash.update(challenge.0.as_bytes());
        token_hash.update(local_node.token().as_bytes());
        let token_hash: Box<[u8]> = token_hash.finalize().as_slice().into();

        Self {
            build_hash,
            token_hash,
        }
    }

    fn test(&self, challenge: &Challenge, local_node: &LocalNode) -> Result<(), ChallengeError> {
        let actual = ChallengeReply::new(local_node, challenge);

        match (
            self.build_hash == actual.build_hash,
            self.token_hash == actual.token_hash,
        ) {
            (true, true) => Ok(()),
            (true, false) => Err(ChallengeError::TokensDiffer),
            (false, true) => Err(ChallengeError::BuildsDiffer),
            (false, false) => Err(ChallengeError::TokenAndBuildDiffer),
        }
    }
}

//------------------------------------------------------------------------------------------------
//  Helper types
//------------------------------------------------------------------------------------------------

/// A [WsStream] that has been successfully challenged
#[derive(Debug)]
pub(crate) struct VerifiedStream(WsStream);

impl Deref for VerifiedStream {
    type Target = WsStream;

    fn deref(&self) -> &Self::Target {
        &self.0
    }
}

impl DerefMut for VerifiedStream {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.0
    }
}

impl Stream for VerifiedStream {
    type Item = RawMsg;

    fn poll_next(
        mut self: std::pin::Pin<&mut Self>,
        cx: &mut std::task::Context<'_>,
    ) -> std::task::Poll<Option<Self::Item>> {
        self.0.poll_next_unpin(cx)
    }
}

#[derive(Debug, Serialize, Deserialize, Clone)]
pub enum ChallengeError {
    TokensDiffer,
    BuildsDiffer,
    TokenAndBuildDiffer,
}

impl Challenge {
    pub(crate) fn new() -> Self {
        Self(Uuid::new_v4())
    }
}

//------------------------------------------------------------------------------------------------
//  as_client
//------------------------------------------------------------------------------------------------

/// Challenge a websocket stream as a server. If succesful, returns a stream that is verified
/// to have been challenged.
pub(crate) async fn as_client(
    local_node: &LocalNode,
    mut stream: WsStream,
) -> Result<(NodeId, VerifiedStream), NodeConnectError> {
    // Wait for a challenge to be sent
    let val = stream.recv().await;
    match into_msg!(val)?.as_challenge()? {
        msg::Challenge::Init(challenge) => {
            // Send back a reply
            let response = ChallengeReply::new(&local_node, &challenge);
            stream
                .send_challenge(msg::Challenge::Reply(response))
                .await?;
        }
        msg => {
            return Err(NodeConnectError::Protocol(
                Box::new(msg::Msg::Challenge(msg)),
                "expected Challenge",
            ))
        }
    }

    // Wait for the challenge result
    let val = stream.recv().await;
    match into_msg!(val)?.as_challenge()? {
        msg::Challenge::Result(result) => {
            if let Err(e) = result {
                return Err(e.into());
            };
        }
        msg => {
            return Err(NodeConnectError::Protocol(
                Box::new(msg::Msg::Challenge(msg)),
                "expected ChallengeResult",
            ))
        }
    }

    // Create and send a new challenge
    let challenge = Challenge::new();
    stream
        .send_challenge(msg::Challenge::Init(challenge))
        .await?;

    // Receive the challenge reply
    let val = stream.recv().await;
    match into_msg!(val)?.as_challenge()? {
        msg::Challenge::Reply(reply) => {
            match reply.test(&challenge, &local_node) {
                Err(e) => {
                    // Send back a failure result
                    stream
                        .send_challenge(msg::Challenge::Result(Err(e.clone())))
                        .await?;
                    return Err(e.into());
                }
                Ok(_) => {
                    // Send back a success result
                    stream
                        .send_challenge(msg::Challenge::Result(Ok(())))
                        .await?;
                }
            }
        }
        msg => {
            return Err(NodeConnectError::Protocol(
                Box::new(msg::Msg::Challenge(msg)),
                "expected ChallengeReply",
            ))
        }
    }

    // Then exchange node ids
    let node_id = exchange_node_ids(local_node, &mut stream).await?;

    // Challenge is now complete, we can return the challenged stream
    Ok((node_id, VerifiedStream(stream)))
}

//------------------------------------------------------------------------------------------------
//  as_server
//------------------------------------------------------------------------------------------------

pub(crate) async fn as_server(
    local_node: &LocalNode,
    mut stream: WsStream,
) -> Result<(NodeId, VerifiedStream), NodeConnectError> {
    // Create and send a new challenge
    let challenge = Challenge::new();
    stream
        .send_challenge(msg::Challenge::Init(challenge))
        .await?;

    // Receive the challenge reply
    let val = stream.recv().await;
    match into_msg!(val)?.as_challenge()? {
        msg::Challenge::Reply(reply) => {
            match reply.test(&challenge, &local_node) {
                Err(e) => {
                    // Send back a failure result
                    stream
                        .send_challenge(msg::Challenge::Result(Err(e.clone())))
                        .await?;
                    return Err(e.into());
                }
                Ok(_) => {
                    // Send back a success result
                    stream
                        .send_challenge(msg::Challenge::Result(Ok(())))
                        .await?;
                }
            }
        }
        msg => {
            return Err(NodeConnectError::Protocol(
                Box::new(msg::Msg::Challenge(msg)),
                "expected ChallengeReply",
            ))
        }
    }

    // Wait for a challenge to be sent
    let val = stream.recv().await;
    match into_msg!(val)?.as_challenge()? {
        msg::Challenge::Init(challenge) => {
            // Send back a reply
            let response = ChallengeReply::new(&local_node, &challenge);
            stream
                .send_challenge(msg::Challenge::Reply(response))
                .await?;
        }
        msg => {
            return Err(NodeConnectError::Protocol(
                Box::new(msg::Msg::Challenge(msg)),
                "expected Challenge",
            ))
        }
    }

    // Wait for the challenge result
    let val = stream.recv().await;
    match into_msg!(val)?.as_challenge()? {
        msg::Challenge::Result(result) => {
            if let Err(e) = result {
                return Err(e.into());
            };
        }
        msg => {
            return Err(NodeConnectError::Protocol(
                Box::new(msg::Msg::Challenge(msg)),
                "expected ChallengeResult",
            ))
        }
    }

    // Then exchange node ids
    let node_id = exchange_node_ids(local_node, &mut stream).await?;

    // Challenge is now complete, we can return the challenged stream
    Ok((node_id, VerifiedStream(stream)))
}

async fn exchange_node_ids(
    local_node: &LocalNode,
    stream: &mut WsStream,
) -> Result<NodeId, NodeConnectError> {
    stream
        .send_challenge(msg::Challenge::ExchangeIds(local_node.node_id()))
        .await?;

    let raw = stream.recv().await;
    match into_msg!(raw)?.as_challenge()? {
        msg::Challenge::ExchangeIds(node_id) => Ok(node_id),
        msg => Err(NodeConnectError::Protocol(
            Box::new(msg::Msg::Challenge(msg)),
            "expected NodeId",
        )),
    }
}
